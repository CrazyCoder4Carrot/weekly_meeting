# Mafia Week 2
11/27/2016, Presented by **Zhenbang Liu** and ** Hongqiao Li**.

This week, Liu talked about consistency of distribution system. Li focused on sharing knowledge with different Knapsack problems.
## Knapsack Problems
There are kinds of Knapsack problems but the following three is typical.
### 0/1 Knapsack
Given two integer arrays val[0..n-1] and wt[0..n-1] which represent values and weights of n items. Also, given an integer W which represents bag capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. You can either pick the complete item, or donâ€™t pick it.

A simple brute force solution is to calculate all the subsets of the values such that the sum of their weight is less than W, then find the maximum value subset. The subsets of an array with n elements is 2^n. When n becomes large, it's not a better way to solve this problem. Any optimal solution? The answer is definite. We can use the dynamic problem to solve this problem.
#### Optimal solution-Dynamic Solution
For each items in the array, there are two cases: 1) included in the optimal subset,2) not included in the optimal subset. Thus, we can get the optimal solutions for their subproblems, so the definition of `dp[i][j]` can be as follows:

1) Maximum value obtained by `(i-1)` items and `j` weight, the `ith` item not included.

2) Maximum value obtained by `(i-1)` items and `(j-weight of the ith item)`, the `ith` item included.

The following shares two ways of the dynamic implementation.
#### Top-down recursion
```python
def knapSack_top(wts,vals,n,maxw):
    if n==0 or maxw==0:
        return 0
    # If weight of the nth item is more than capacity.
    # it can't be included
    if (wts[n-1]>maxw):
        return knapSack_top(wts,vals,n-1,maxw)
    else:
        return max(val[n-1]+knapSack_top(wts,vals,n-1,maxw-wts[n-1]),
                   knapSack_top(wts,vals,n-1,maxw))
```
#### Bottom-up memorization
```python
def knapSack_bottom(wts,vals,maxw):
    n=len(vals)
    if n==0 or maxw==0:
        return 0
    dp=[[0 for _ in xrange(maxw+1)] for _ in xrange(n+1)]

    for i in xrange(1,n+1):
        for j in xrange(maxw+1):
            if wts[i-1]<=j:
                dp[i][j]=max(dp[i-1][j],dp[i-1][j-wts[i-1]]+vals[i-1])
            else:
                dp[i][j]=dp[i-1][j]
    return dp[n][maxw]
```
### Complete Knapsack

### Group Knapsack

## Reference 
* Dynamic Programming for 0/1 [Knapsack](http://www.geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/).