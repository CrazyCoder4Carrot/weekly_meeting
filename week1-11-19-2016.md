# Mafia Week 1
11/19/2016, Presented by **Zhenbang Liu** and ** Zheng Yang**.

This week, Liu talked about SQL vs. NoSQL and a highly available distributed system Dynamo. Also, Yang shared some typical graph interview questions and algorithms.
## SQL&NoSQL
### Features
Liu talked about the differences between SQL and NoSQL. SQL stores as a table while NoSQL usually documents as JSON file. SQL has primary keys, indexes, relationships, triggers and stored procedures, but NoSQL has no such features. SQL do normalization in most scenarios, however, NoSQL uses denormalization to improve the read performance. A sample of NoSQL JSON could be like this:
```json
{
  ISBN: 9780992461225,
  title: "JavaScript: Novice to Ninja",
  author: "Darren Jones",
  format: "ebook",
  price: 29.00
}
```
We also covered SQL join, data integrity, performance and scaling when comparing the two. The ACID compliance (Atomicity, Consistency, Isolation, Durability) get involved when discussing different scenarios.
### Summary
#### SQL
* Logical related discrete data requirements which can be identified up-front.
* Data integrity is essential.
* Standards-based proven technology with good developer experience and support.
#### NoSQL
* Unrelated, indeterminate or evolving data requirements.
* Simpler or looser project objectives, able to start coding immediately.
* Speed and scalability is imperative.

## Dynamo
### What it is
Dynamo is a highly available distributed key-value storage system. It sacrifices consistency for availability. Also, using synthesis of well known techniques, such as consistent hashing, object versioning, conflict resolution to achieve scalability and availability. In practical, some of Amazon's key product use this system. It's friendly to scale up and flexible for many apps. But it depends on the following assumptions and requirements:
* Simple query model
* No ACID properties
* Stringent latency requirements
* Non-hostile environment

Next, we talked the SLAs(Service Level Agreements), consistency and heterogeneity. At last, the variant of consistent hashing and vector clock have been explained in details with two examples.

To know the detail of the presentation, please go to the [reference](#References) parts.

## Algorithm
In the second part, Yang shared us with several typical graph and mathematical problem.

### Maximum XOR of Two Numbers in an Array
The original descripiton of this question is [here](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/), I strongly recommend you to try this yourself first. To solve this problem, we need to identify the MSB(most significant bit) when doing the XOR operation. The `Trie` is a better to solve this problem. If you don't have much experience of  `Trie`. There is a way using bit manipulation. It's also start to identify the MSB in those numbers.

For example, if we have an array of `[14,10,7,2]` and the binary format would be `[1110, 1010, 0111, 0010]`. Let's start with MSB=3. The mask for MSB=3 is `1000`. Using a hashset to record all the value of `num&mask`, so the set contains `[1000,0000]`. At this time, the maximum candidate could be `1000` since we can find two values XOR `1000^0000` equals the maximum. For next iteration, we try the MSB=2 and the mask is `1100`. And the result would be like this:
```
Array=[1110, 1010, 0111, 0010]
i=3 mask=1000  set={1000,0000} candicate=1000, max=1000
i=2 mask=1100  set={1100,1000,0100,0000} candicate=1100, max=1100
i=1 mask=1110  set={1110,1010,0110,0010} candicate=1110, can't find two value XOR equal candicate, max remains 1100
i=0 mask=1111  set={1110, 1011, 0111, 0010} candicate=1111, can't find two value XOR equal candicate, max remains 1100
```
And the code could be like:
```python
def findMaximumXOR(nums):
        mask=maxnum=0
        for i in xrange(31,-1,-1):
            mask|=1<<i
            hashset=set()
            # get each most significant bit
            for num in nums:
                hashset.add(num&mask)
            # for the maxnum candicate, try to find each bit
            candicate=maxnum|(1<<i)
            # for each bit hashset, if the pre and candicate^pre in hashset
            # candidate (candicate^pre^pre) should be the maxnum
            for pre in hashset:
                if candicate^pre in hashset:
                    maxnum=candicate
        return maxnum
```
### 10^9th Fibonacci Number

### Shortest Path with Weights

### Other Problem to Crack
* [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)
* [Word Search II](https://leetcode.com/problems/word-search-ii/)
* [Add and Search Word-Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/)
* Word Squares

## Q&A

## References
* The original [paper](https://drive.google.com/file/d/0BxbEECTuylbRQ3hLTEtJS0dLdHc/view?usp=sharing) we discussed in this week.
* To know more about SQL&NoSQL, you can go [here](https://www.sitepoint.com/sql-vs-nosql-differences/).
